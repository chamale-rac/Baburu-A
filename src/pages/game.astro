---

---

<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Making your first Phaser 3 Game - Part 10</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js" is:inline></script>
    <style type="text/css">
        body {
            margin: 0;
            align-items: center;
            justify-content: center;
            display: flex;
            height: 100vh;
        }
    </style>
</head>
<body>

    <script type="text/javascript">

        var config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 500 }, // Increased gravity for a more responsive jump
                    debug: false // Set to true for debugging physics bodies
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        var player;
        var platforms;
        var cursors;
        var score = 0;
        var highestPoint = 0;
        var scoreText;
        var stars;
        var bombs;
        var gameOver = false;
        var camera;

        var game = new Phaser.Game(config);

        function preload ()
        {
            // Load local assets
            this.load.image('sky', 'assets/universe.png');
            // Replace 'ground' with 'ground_bubble'
            this.load.image('ground_bubble', 'assets/ground_bubble.png');
            this.load.image('star', 'assets/good.png');
            this.load.image('bomb', 'assets/bad.png');
            this.load.spritesheet('dude',
                'assets/astro.png',
                { frameWidth: 32, frameHeight: 48 }
            );

            // Optional: Load explosion assets
            this.load.spritesheet('explosion', 'assets/explosion.png', {
                frameWidth: 64,
                frameHeight: 64
            });
            // Optional: Load explosion sound
            // this.load.audio('explosion_sound', 'assets/explosion_sound.mp3');
        }

        function create ()
        {
            // 1. Add a scrolling background
            this.sky = this.add.tileSprite(400, 300, 800, 600, 'sky');
            this.sky.setScrollFactor(0);

            // 2. Create the platforms group using 'ground_bubble'
            platforms = this.physics.add.staticGroup();

            // 3. Create initial ground bubble platform
            let initialBubble = platforms.create(400, 580, 'ground_bubble').setScale(2).refreshBody();
            initialBubble.hasCollided = false;

            // 4. Generate initial bubble platforms below the ground
            generateInitialPlatforms.call(this);

            // 5. Create the player
            player = this.physics.add.sprite(400, 450, 'dude');

            // 6. Player physics properties
            player.setBounce(0.2);
            player.setCollideWorldBounds(true);

            // 7. Player animations
            createPlayerAnimations.call(this);

            // 8. Input Events
            cursors = this.input.keyboard.createCursorKeys();

            // 9. Stars group
            stars = this.physics.add.group({
                key: 'star',
                repeat: 1,
                setXY: { x: 12, y: 0, stepX: 140 }
            });

            stars.children.iterate(function (child) {
                child.setBounceY(Phaser.Math.FloatBetween(0.4, 0.8));
            });

            // 10. Bombs group
            bombs = this.physics.add.group();

            // 11. Score Text
            scoreText = this.add.text(16, 16, 'Height: 0', { fontSize: '32px', fill: '#000' })
                .setScrollFactor(0) // Keeps the text fixed on the screen
                .setDepth(10); // Ensures it's rendered above other elements

            // 12. Colliders
            // Use platformCollision as the processCallback for one-way platforms
            this.physics.add.collider(player, platforms, null, platformCollision, this);
            this.physics.add.collider(stars, platforms);
            this.physics.add.collider(bombs, platforms);

            // 13. Overlaps
            this.physics.add.overlap(player, stars, collectStar, null, this);
            this.physics.add.collider(player, bombs, hitBomb, null, this);

            // 14. Camera setup
            camera = this.cameras.main;
            camera.startFollow(player, true, 0.05, 0.05);
            camera.setBounds(0, -10000, 800, 20000); // Adjusted to allow upward movement

            // 15. Set Physics World Bounds
            this.physics.world.setBounds(0, -10000, 800, 20000); // Large bounds to prevent barriers

            // Optional: Create explosion animation
            if (this.textures.exists('explosion')) {
                this.anims.create({
                    key: 'explode',
                    frames: this.anims.generateFrameNumbers('explosion', { start: 0, end: 15 }),
                    frameRate: 20,
                    hideOnComplete: true
                });
            }
        }

        function update ()
        {
            if (gameOver)
            {
                return;
            }

            // 1. Player movement
            handlePlayerMovement.call(this);

            // 2. Update score based on player's highest position
            updateScore.call(this);

            // 3. Generate new platforms dynamically
            generatePlatforms.call(this);

            // 4. Remove platforms, stars, and bombs that are out of view
            cleanupObjects.call(this);

            // 5. Scroll the background for a parallax effect
            this.sky.tilePositionY = camera.scrollY * 0.5;
        }

        // Function to generate initial platforms
        function generateInitialPlatforms() {
            for (let i = 1; i < 10; i++) { // Start from 1 to avoid overlapping with the ground
                let x = Phaser.Math.Between(50, 750);
                let y = 600 - i * 80; // Spread platforms vertically

                // For that y position instantiate a bubble platform, this means more than one bubble platform can be created

                let randomBubblesAmount = Phaser.Math.Between(2, 5); // Randomize the amount of bubble platforms

                for (let j = 0; j < randomBubblesAmount; j++) {
                    let bubble = platforms.create(x + j * 50, y, 'ground_bubble');
                    bubble.hasCollided = false; // Initialize collision state
                }
            }
        }

        // Function to create player animations
        function createPlayerAnimations() {
            this.anims.create({
                key: 'left',
                frames: this.anims.generateFrameNumbers('dude', { start: 0, end: 3 }),
                frameRate: 10,
                repeat: -1
            });

            this.anims.create({
                key: 'turn',
                frames: [ { key: 'dude', frame: 4 } ],
                frameRate: 20
            });

            this.anims.create({
                key: 'right',
                frames: this.anims.generateFrameNumbers('dude', { start: 5, end: 8 }),
                frameRate: 10,
                repeat: -1
            });
        }

        // Function to handle player movement
        function handlePlayerMovement() {
            if (cursors.left.isDown)
            {
                player.setVelocityX(-160);
                player.anims.play('left', true);
            }
            else if (cursors.right.isDown)
            {
                player.setVelocityX(160);
                player.anims.play('right', true);
            }
            else
            {
                player.setVelocityX(0);
                player.anims.play('turn');
            }

            if (cursors.up.isDown && player.body.touching.down)
            {
                player.setVelocityY(-550); // Adjusted jump velocity for higher jumps
            }

            // add an extra jump in the air to make the game more fun
            if (cursors.space.isDown && !player.body.touching.space && player.body.velocity.y > 0) {
                player.setVelocityY(-550);
            }
        }

        // Function to update the score based on the highest point reached
        function updateScore() {
            // In Phaser, the y-axis increases downwards. To track height, we use the smallest y value.
            if (player.y < highestPoint || highestPoint === 0)
            {
                highestPoint = player.y;
                score = Math.max(score, 600 - highestPoint); // Assuming initial y is 600
                scoreText.setText('Height: ' + score);
            }
        }

        // Function to generate new platforms dynamically
        function generatePlatforms() {
            platforms.children.iterate(function (platform) {
                // If a platform is above the current camera view, reposition it below
                if (platform.y > camera.scrollY + 800)
                {
                    // Reposition the platform to just above the camera view, within a reachable range
                    platform.y = camera.scrollY - Phaser.Math.Between(50, 150);
                    platform.x = Phaser.Math.Between(50, 750);

                    // Reset the collision state
                    platform.hasCollided = false;

                    // Important: Refresh the physics body after repositioning
                    platform.refreshBody();

                    // Optionally add stars to new platforms
                    if (Phaser.Math.Between(0, 6) == 1) {
                        let newStar = stars.create(platform.x, platform.y - 30, 'star');
                        newStar.setBounceY(Phaser.Math.FloatBetween(0.4, 0.8));
                    }

                    // Optionally add bombs to increase difficulty
                    if (Phaser.Math.Between(0, 10) === 1) {
                        let bomb = bombs.create(platform.x, platform.y - 50, 'bomb');
                        bomb.setBounce(1);
                        bomb.setCollideWorldBounds(true);
                        bomb.setVelocity(Phaser.Math.Between(-200, 200), 20);
                        bomb.allowGravity = false;
                    }
                }
            }, this);
        }

        // Function to clean up objects that are out of view
        function cleanupObjects() {
            // Remove stars that are below the camera view
            stars.children.iterate(function (star) {
                if (star && star.y > camera.scrollY + 600) {
                    star.destroy();
                }
            }, this);

            // Remove bombs that are below the camera view
            bombs.children.iterate(function (bomb) {
                if (bomb && bomb.y > camera.scrollY + 600) {
                    bomb.destroy();
                }
            }, this);
        }

        // Function to collect stars
        function collectStar (player, star)
        {
            this.physics.pause();

            player.setTint(0xff0000);

            player.anims.play('turn');

            gameOver = true;

            // Display Game Over text centered on the screen
            this.add.text(camera.scrollX + 400, camera.scrollY + 300, 'Game Over', { fontSize: '64px', fill: '#ff0000' }).setOrigin(0.5);

        }

        // Function to handle player hitting a bomb
        function hitBomb (player, bomb)
        {
            this.physics.pause();

            player.setTint(0xff0000);

            player.anims.play('turn');

            gameOver = true;

            // Display Game Over text centered on the screen
            this.add.text(camera.scrollX + 400, camera.scrollY + 300, 'Game Over', { fontSize: '64px', fill: '#ff0000' }).setOrigin(0.5);
        }

        /**
         * Custom Collision Callback for One-Way Platforms
         *
         * This function determines whether the player should collide with a platform.
         * The player will only collide with the platform if they are falling down onto it.
         * If the player is moving upwards (jumping), they will pass through the platform.
         */
        function platformCollision(player, platform)
        {
            const playerBody = player.body;
            const platformBody = platform.body;

            // Check if the player is falling
            if (playerBody.velocity.y > 0)
            {
                const playerBottom = player.y + playerBody.height / 2;
                const platformTop = platform.y - platformBody.height / 2;

                // Allow collision only if the player is above the platform
                if (playerBottom <= platformTop) {
                    // Trigger explosion if not already collided
                    if (!platform.hasCollided) {
                        platform.hasCollided = true; // Mark as collided to prevent multiple triggers
                        startBubbleExplosion.call(this, platform);
                    }
                    return true;
                }
            }

            // Prevent collision
            return false;
        }

        // Function to start the bubble explosion timer
        function startBubbleExplosion(platform) {
            // Start a 3-second timer
            this.time.delayedCall(3000, () => {
                explodeBubble.call(this, platform);
            }, [], this);
        }

        // Function to handle the bubble explosion
        function explodeBubble(platform) {
            // Optional: Play explosion sound
            // this.sound.play('explosion_sound');

            // Optional: Play explosion animation
            if (this.textures.exists('explosion')) {
                let explosion = this.add.sprite(platform.x, platform.y, 'explosion');
                explosion.setScale(1.5);
                this.physics.world.enable(explosion);
                explosion.body.setAllowGravity(false);

                // Play the explosion animation
                explosion.anims.play('explode');

                // Destroy the bubble platform after the animation
                explosion.on('animationcomplete', () => {
                    platform.destroy();
                    explosion.destroy();
                });
            } else {
                // If no explosion animation, simply destroy the platform
                platform.destroy();
            }
        }

    </script>
</body>
</html>
